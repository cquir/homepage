<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>Christian Quirouette</title>
		<link rel="stylesheet" href="styles.css">
	</head>
	<body>

	<header class="container">
		<h1 class="test">Christian Quirouette</h1>
		<div class="links">
			<a href="https://linkedin.com/in/christian-quirouette-791b53193/"><img class="logo" src="images/LI-logo.png"></a>
			<a href="https://www.github.com/cquir"><img class="logo" src="images/github-mark-white.png"></a>
		</div>
	</header>

	<div class="container summary">
		<p>
			Highly adaptable researcher with 4+ years experience solving problems, mainly in virology, using computational or mathematical methods.
		</p>
	</div>

    <div class="container highlights">
        <h1>Highlighted projects</h1>
		<a class="publications" href="https://doi.org/10.1371/journal.pcbi.1007705">
			<p>
				<b>A mathematical model describing the localization and spread of influenza A virus infection within the human respiratory tract</b>
				C Quirouette, NP Younis, MB Reddy, CAA Beauchemin
			</p>
		</a>
		<a class="publications" href="https://arxiv.org/abs/2208.00637">
			<p>
				<b>Stochastic failure of cell infection post viral entry: Implications for infection outcomes and antiviral therapy</b>
				C Quirouette, D Cresta, J Li, KP Wilkie, H Liang, CAA Beauchemin 
			</p>
		</a>
    </div>

	<canvas class="webgl"></canvas>
	<script type="module">

	import * as THREE from 'https://unpkg.com/three/build/three.module.js';

	// Canvas
	const canvas = document.querySelector('canvas.webgl');

	// Scene
	const scene = new THREE.Scene();

	/**
	 * Objects
	 */
	const geometry = new THREE.BoxGeometry(1,1,1);
	const material = new THREE.MeshBasicMaterial({color:0x50fa7b});
	const cube = new THREE.Mesh(geometry,material);
	cube.position.set(-1,1,0);
	scene.add(cube);

	let positions = [
		[-1,0,0],
		[-1,-1,0],
		[0,-1,0],
		[0,-2,0],
		[1,-2,0],
		[1,-3,0],
		[2,-3,0],
		[2,-4,0],
		[2,-4,1],
		[2,-5,1],
		[2,-5,2]
	];

	const staircaseMaterial = new THREE.MeshBasicMaterial({color:0x50fa7b,wireframe:true});
	for (let i=0; i <positions.length; i++){
		const staircaseElement = new THREE.Mesh(geometry,staircaseMaterial);
		staircaseElement.position.fromArray(positions[i]);
		scene.add(staircaseElement);
	}

	/**
	 * Sizes
	 */
	 const sizes = {
		width: 0.25*window.innerWidth,
		height: window.innerHeight
	}

	window.addEventListener('resize', () =>
	{
		sizes.width = 0.25*window.innerWidth;
		sizes.height = window.innerHeight;

		// Update camera
		camera.aspect = sizes.width/sizes.height;
		camera.updateProjectionMatrix();

		// Update renderer
		renderer.setSize(sizes.width,sizes.height);
		renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
	})

	/**
	 * Camera
	 */
	const camera = new THREE.PerspectiveCamera(35,sizes.width/sizes.height,0.1,100);
	const cameraDistance = 8;
	camera.position.set(cameraDistance,cameraDistance,cameraDistance);
	camera.lookAt(0,-2.5,0);
	/**
	 * Renderer
	 */	
	const renderer = new THREE.WebGLRenderer({
		canvas : canvas,
		alpha: true,
		antialias: true,
	});

	renderer.setSize(sizes.width,sizes.height);
	renderer.setPixelRatio(Math.min(window.devicePixelRatio,2))
	document.body.appendChild(renderer.domElement);

	// Clock
	const clock = new THREE.Clock();

	/**
	 * Animate
	 */
	let step = 0;
	let direction = 1;
	let theta = 0;
	const angularSpeed = 2;

	function animate() {
		requestAnimationFrame(animate);

		let dt = clock.getDelta();

		if (step >= 0 && step <= 4){

			theta = theta+angularSpeed*dt > Math.PI? Math.PI: theta+angularSpeed*dt;

			let start = new THREE.Vector3(-1,1,0);
			let pivot = new THREE.Vector3(-0.5,0.5,0.5);
			let axis = new THREE.Vector3(0,0,0);

			if (step < 3){

				start.addScaledVector(new THREE.Vector3(1,-1,0),step);
				pivot.addScaledVector(new THREE.Vector3(1,-1,0),step);
				axis.z = 1;

			} else {

				start.addScaledVector(new THREE.Vector3(1,-1,0),3).addScaledVector(new THREE.Vector3(0,-1,1),step-3);
				pivot.addScaledVector(new THREE.Vector3(1,-1,0),3).addScaledVector(new THREE.Vector3(0,-1,1),step-3);
				axis.x = 1;

			}

			cube.position.copy(start);
			cube.position.sub(pivot);
			cube.position.applyAxisAngle(axis,Math.pow(-1,step<3)*direction*theta+(direction==-1)*Math.PI);
			cube.position.add(pivot);
			cube.setRotationFromAxisAngle(axis,Math.pow(-1,step<3)*direction*theta+(direction==-1)*Math.PI);
		}

		if (theta == Math.PI){
			theta = 0;
			step += direction;
		}

		// Reset

		if (step == 5){
			step = 4;
			direction = -1;
		}

		if (step == -1){
			step = 0;
			direction = 1;
		}

		renderer.render(scene,camera);
	}

	animate();
	</script>
	</body>
</html>